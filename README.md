# گزارش نهایی پروژه – استقرار یک نرم‌افزار Frontend استاتیک با GitHub Actions

## ابزارها و تکنولوژی‌های مورد استفاده

در این پروژه از ابزارها و فناوری‌های زیر برای پیاده‌سازی، مدیریت و استقرار استفاده شده است:

- **Git**: برای مدیریت نسخه‌ها و همکاری تیمی بر روی کد.
- **GitHub**: به عنوان پلتفرم میزبانی کد و مدیریت مخزن.
- **GitHub Actions**: برای ایجاد فرآیند استقرار خودکار پروژه.
- **HTML و CSS**: برای طراحی و پیاده‌سازی رابط کاربری وب‌سایت استاتیک.

---

## مرحله اول: ایجاد مخزن و پروژه در GitHub

ابتدا یک مخزن جدید در GitHub ایجاد کردیم تا کدهای پروژه را در آن نگهداری کنیم. پس از ایجاد مخزن، یک پروژه نیز در قسمت Projects ایجاد شد که به Kanban board مجهز بود. با استفاده از این برد، وظایف پروژه را بین اعضای تیم تقسیم و پیشرفت را مدیریت کردیم.

تصویر مربوط به ایجاد مخزن:
![ایجاد مخزن](./pics/Screenshot%20from%202025-07-22%2000-17-26.png)

تصاویر مربوط به ایجاد پروژه و مشاهده برد وظایف:
![ساخت پروژه و اتصال آن](./pics/Screenshot%20from%202025-07-22%2000-18-11.png)  
![برد وظایف](./pics/Screenshot%20from%202025-07-22%2000-20-16.png)

---

## مرحله دوم: کلون کردن مخزن و افزودن فایل `.gitignore`

پس از ایجاد مخزن، با استفاده از دستور `git clone` آن را به صورت محلی کلون کردیم تا بتوانیم روی سیستم خود تغییرات را اعمال کنیم. سپس فایل `.gitignore` ایجاد شد.

### فایل `.gitignore` چیست؟
فایلی است که به Git اعلام می‌کند کدام فایل‌ها یا پوشه‌ها نباید وارد مخزن شوند. به عنوان مثال فایل‌های خروجی، فایل‌های سیستمی، پوشه‌های وابستگی مانند `node_modules` یا `build/` در پروژه‌های واقعی معمولاً در این فایل قرار می‌گیرند تا باعث سنگین شدن مخزن و ایجاد مشکل در همکاری نشوند.

وضعیت مخزن قبل از اولین commit و اضافه کردن `.gitignore`:
![وضعیت مخزن](./pics/Screenshot%20from%202025-07-22%2000-28-37.png)

---

## مرحله سوم: پیاده‌سازی استقرار خودکار با GitHub Actions

برای استقرار خودکار پروژه، یک فایل workflow در مسیر `.github/workflows/deploy.yml` ایجاد کردیم. این فایل شامل دستوراتی است که به GitHub Actions می‌گوید هنگام push به شاخه `main`، سایت به صورت خودکار بر روی GitHub Pages منتشر شود.

ایجاد فایل workflow:
![ساخت فایل workflow](./pics/Screenshot%20from%202025-07-22%2000-35-29.png)

محتوای فایل:
![نمایش محتوای فایل workflow](./pics/Screenshot%20from%202025-07-22%2000-37-27.png)

افزودن فایل و انجام commit:
![اضافه شدن فایل به مخزن](./pics/Screenshot%20from%202025-07-22%2000-39-22.png)

---

## مرحله چهارم: فعال کردن GitHub Pages

برای انتشار پروژه بر روی اینترنت از طریق GitHub Pages، به تنظیمات مخزن رفتیم و در بخش Pages، منبع انتشار را به GitHub Actions تغییر دادیم.

این کار باعث می‌شود هر زمان که تغییر جدیدی در شاخه main انجام شود، workflow اجرا شده و نسخه جدید سایت منتشر شود.

![تنظیمات انتشار از GitHub Actions](./pics/Screenshot%20from%202025-07-22%2000-41-02.png)

---

## ساختار شاخه‌ها (Branches)

برای مدیریت بهتر توسعه، از چندین شاخه استفاده کردیم:

| شاخه             | توضیح                                                   |
| ---------------- | ------------------------------------------------------- |
| `main`           | شاخه اصلی و نهایی پروژه که محافظت شده و قابل انتشار است |
| `dev`            | شاخه توسعه که همه ویژگی‌ها ابتدا در آن ادغام می‌شوند    |
| `feature/header` | توسعه و طراحی بخش هدر سایت                              |
| `feature/footer` | توسعه و طراحی بخش پایینی سایت                           |
| `feature/about`  | ساخت بخش "درباره ما" سایت                               |

در این پروژه، مدیریت شاخه‌ها با یک الگوی منظم انجام شد. شاخه‌ی `main` به عنوان نسخه‌ی نهایی پروژه محافظت شده بود و تنها از طریق Pull Request به‌روزرسانی می‌شد. شاخه‌ی `dev` نقش فضای اصلی توسعه را ایفا می‌کرد. برای هر قابلیت جدید، شاخه‌ای مستقل با پیشوند `feature/` ایجاد شده و پس از تکمیل، به `dev` ادغام می‌شد. این روند باعث شد توسعه ویژگی‌ها به صورت جداگانه انجام شود و در نهایت پس از بررسی کلی، تغییرات به `main` منتقل گردند.

---

## گزارش کامیت‌ها

در طول پروژه، بیش از ۲۰ کامیت معنادار انجام شده است که هر یک مربوط به یک تغییر یا افزودن قابلیت مشخص در پروژه بوده‌اند. این کامیت‌ها شامل ایجاد ساختار اولیه، اضافه کردن بخش‌های مختلف سایت (هدر، فوتر، درباره‌ما)، رفع مشکلات، اضافه کردن استایل و پیاده‌سازی استقرار خودکار بوده‌اند. متن هر commit به طور دقیق نشان می‌دهد که چه تغییری اعمال شده و هدف آن چه بوده است. این رویکرد به خوانایی تاریخچه توسعه و پیگیری روند پیشرفت کمک شایانی کرده است.

---

## محافظت از شاخه main و استفاده از Pull Request

برای جلوگیری از تغییر مستقیم در شاخه `main`، از بخش Settings → Branches، قوانینی وضع کردیم تا تنها از طریق Pull Request امکان ادغام با main وجود داشته باشد.

این کار باعث افزایش امنیت، کاهش خطا و بررسی دقیق‌تر کد قبل از انتشار می‌شود.

![قوانین محافظتی شاخه main](./pics/Screenshot%20from%202025-07-22%2010-15-01.png)

تمام ادغام‌ها از طریق Pull Request انجام شد و در دو مورد، تعارض‌هایی (conflict) ایجاد شد که آن‌ها را به صورت دستی در GitHub رفع کردیم.

---

## دستورات Git مورد استفاده در طول پروژه

برای مدیریت مخزن و توسعه پروژه، از دستورات متعددی استفاده شد که مهم‌ترین آن‌ها عبارتند از:

```bash
git stash  
git commit  
git fetch  
git merge  
git checkout  
git status  
git branch  
git pull  
git log  
git push  
git add  
git rebase  
git diff
```

---
## پاسخ سوالات

# ۱. پوشه `.git` چیست؟

پوشه `.git` یک دایرکتوری مخفی است که Git، سیستم کنترل نسخه، از آن برای مدیریت کل تاریخچه پروژه استفاده می‌کند. وقتی یک پروژه با Git مقداردهی اولیه می‌شود (initialize)، Git این پوشه را در ریشه پروژه ایجاد می‌کند و تمام اطلاعات مربوط به کنترل نسخه را در آن نگه می‌دارد.

به عبارت دیگر، این پوشه قلب سیستم Git است و همه چیز از جمله تاریخچه commitها، شاخه‌ها (branches)، تگ‌ها (tags)، اطلاعات ریموت، وضعیت فایل‌ها و... در آن ذخیره می‌شود.

## چه اطلاعاتی در `.git` ذخیره می‌شود؟

پوشه `.git` شامل چندین فایل و زیرپوشه کلیدی است:

### 1. `HEAD`

* نشان می‌دهد که هم‌اکنون روی کدام شاخه (branch) قرار دارید.
* مثال:

  ```
  ref: refs/heads/main
  ```

### 2. `config`

* فایل تنظیمات محلی Git برای این پروژه.
* شامل اطلاعاتی مثل نام کاربر، آدرس ریموت (origin)، alias‌ها، و...

### 3. `description`

* در پروژه‌های bare (پروژه‌هایی بدون فایل‌های کاری)، توضیحی در مورد repository در این فایل نوشته می‌شود.

### 4. `hooks/`

* اسکریپت‌هایی که قبل یا بعد از رخ دادن اتفاقاتی خاص (مثل commit یا push) اجرا می‌شوند.
* برای automation (مثلاً بررسی کیفیت کد قبل از commit) کاربرد دارند.

### 5. `info/`

* اطلاعات اضافی و محلی (مثل `.gitignore` سراسری) را ذخیره می‌کند.

### 6. `objects/`

* مهم‌ترین بخش Git. تمام داده‌ها به صورت هش‌شده (SHA-1) در این پوشه نگهداری می‌شوند.
* شامل:

  * فایل‌ها (blobs)
  * دایرکتوری‌ها (trees)
  * commitها

### 7. `refs/`

* حاوی اطلاعات مربوط به شاخه‌ها (branches)، تگ‌ها (tags) و ریموت‌ها.

### 8. `logs/`

* تاریخچه تغییرات head و شاخه‌ها. هر commit یا تغییر شاخه در اینجا ثبت می‌شود.

## چگونه پوشه `.git` ساخته می‌شود؟

برای ایجاد این پوشه کافی‌ست یک مخزن Git جدید را مقداردهی اولیه کنید:

```bash
git init
```

### این دستور چه کار می‌کند؟

* یک پوشه `.git` در ریشه پروژه می‌سازد.
* ساختار داخلی Git را آماده می‌کند تا بتوانید commit انجام دهید.
* پروژه را به یک مخزن Git (Git repository) تبدیل می‌کند.

## مثال عملی

```bash
mkdir my-project
cd my-project
git init
```

حالا اگر دستور `ls -a` را اجرا کنید، می‌بینید:

```
.  ..  .git
```

و با اجرای `tree .git` ساختار اولیه را می‌توانید مشاهده کنید.

## نکته مهم

اگر پوشه `.git` حذف شود:

* تمام تاریخچه Git از بین می‌رود.
* پروژه دیگر یک مخزن Git نخواهد بود.
* امکان بازیابی commitها یا شاخه‌ها وجود نخواهد داشت (مگر با پشتیبان یا remote repository).


---

# ۲. منظور از "Atomic" بودن در Atomic Commit و Atomic Pull Request چیست؟

در سیستم‌های کنترل نسخه مانند Git، واژه "Atomic" به معنای یکپارچه و غیرقابل تقسیم بودن عملیات به‌کار می‌رود. این اصطلاح نشان می‌دهد که هر عملیات باید به صورت کامل، مستقل و قابل بررسی انجام شود.

## 1. Atomic Commit چیست؟

یک commit اتمی (Atomic Commit) به commitی گفته می‌شود که تنها یک تغییر منطقی را شامل می‌شود. هدف این رویکرد افزایش خوانایی، بازبینی ساده‌تر و قابلیت بازگردانی بهتر تغییرات است.

### ویژگی‌های یک commit اتمی:

* شامل فقط یک هدف منطقی مشخص است.
* تغییرات آن کوچک و متمرکز است.
* پیام commit دقیقاً توضیح‌دهنده همان تغییر است.
* مستقل از سایر commitها قابل فهم است.
* قابلیت revert یا cherry-pick شدن دارد.

### مثال اشتباه:

```diff
- افزودن یک تابع جدید در فایل A
- اصلاح یک باگ در فایل B
```

در این مثال، دو تغییر غیرمرتبط در یک commit آمده است که نباید با هم باشند.

### مثال درست:

```diff
✔ افزودن تابع validateInput در فایل A → یک commit
✔ اصلاح باگ در متد fetchData در فایل B → یک commit دیگر
```

هر تغییر منطقی در یک commit جداگانه قرار گرفته است.

## 2. Atomic Pull Request چیست؟

یک pull request اتمی شامل مجموعه‌ای از commitها است که همگی به یک قابلیت یا تغییر منطقی خاص مربوط می‌شوند. چنین pull requestی باید تنها یک موضوع مشخص را پوشش دهد.

### ویژگی‌های یک pull request اتمی:

* فقط commitهای مرتبط با یک موضوع را شامل می‌شود.
* بررسی (code review) آن ساده‌تر و سریع‌تر است.
* ادغام (merge) آن باعث تغییر روشن و مشخص در کد پروژه می‌شود.
* در صورت رد شدن (reject) یا بازگردانی (revert)، فقط همان بخش مشخص تحت تأثیر قرار می‌گیرد.

## دلایل اهمیت atomic بودن

| مزیت                | توضیح                                                      |
| ------------------- | ---------------------------------------------------------- |
| بررسی راحت‌تر       | commit یا PR کوچک و متمرکز سریع‌تر بررسی می‌شود.           |
| اشکال‌زدایی ساده‌تر | منبع خطا راحت‌تر شناسایی می‌شود.                           |
| بازگردانی ساده‌تر   | تغییرات به راحتی و بدون وابستگی برگشت‌پذیرند.              |
| انتقال انتخابی      | امکان انتقال commit به شاخه دیگر با cherry-pick فراهم است. |

## نکات عملی برای حفظ atomic بودن

* هر commit باید فقط یک هدف منطقی را دنبال کند.
* هر pull request باید فقط یک قابلیت، اصلاح یا موضوع خاص را شامل شود.
* برای انتخاب دقیق خطوطی که باید stage شوند، می‌توان از دستور `git add -p` استفاده کرد.

---

# ۳. تفاوت بین دستورات `git fetch`، `git pull`، `git merge`، `git rebase`، و `git cherry-pick`


## 1. دستور `git fetch`

دستور `git fetch` برای دریافت تغییرات جدید از مخزن ریموت به مخزن محلی استفاده می‌شود، بدون آنکه این تغییرات مستقیماً با شاخه فعلی ادغام شوند. این دستور باعث به‌روزرسانی شاخه‌های ریموت در محیط محلی می‌شود و امکان بررسی تغییرات قبل از اعمال فراهم می‌گردد.

مثال:

```bash
git fetch origin
```

## 2. دستور `git pull`

این دستور ترکیبی از `git fetch` و `git merge` است. ابتدا تغییرات را از مخزن ریموت دریافت می‌کند و سپس آن‌ها را به شاخه فعلی ادغام می‌کند. در صورت وجود تضاد بین کدهای محلی و ریموت، نیاز به حل Conflict خواهد بود.

مثال:

```bash
git pull origin main
```

## 3. دستور `git merge`

دستور `merge` برای ادغام تغییرات دو شاخه در یکدیگر استفاده می‌شود. این دستور معمولاً زمانی استفاده می‌شود که توسعه‌دهنده بخواهد تغییرات شاخه‌ای فرعی را به شاخه اصلی منتقل کند. اجرای این دستور معمولاً یک commit جدید از نوع merge ایجاد می‌کند.

مثال:

```bash
git checkout main
git merge feature-branch
```

## 4. دستور `git rebase`

دستور `rebase` برای بازنویسی تاریخچه commitها به کار می‌رود. با استفاده از این دستور، commitهای شاخه فعلی به‌گونه‌ای بازنویسی می‌شوند که انگار مستقیماً روی آخرین commit شاخه مقصد انجام شده‌اند. نتیجه آن یک تاریخچه خطی و تمیز است، اما در صورتی که از این دستور روی شاخه‌های اشتراکی استفاده شود ممکن است باعث بروز مشکلات شود.

مثال:

```bash
git checkout feature
git rebase main
```

## 5. دستور `git cherry-pick`

این دستور برای اعمال یک یا چند commit مشخص از یک شاخه به شاخه فعلی استفاده می‌شود. برخلاف `merge` و `rebase` که با مجموعه‌ای از commitها سروکار دارند، `cherry-pick` به طور انتخابی فقط commitهای مشخص را منتقل می‌کند.

مثال:

```bash
git cherry-pick e3a1b35
```

## جدول مقایسه

| دستور           | عملکرد               | تغییر در فایل‌ها | تاریخچه حفظ می‌شود | کاربرد اصلی              |
| --------------- | -------------------- | ---------------- | ------------------ | ------------------------ |
| git fetch       | دریافت تغییرات ریموت | ندارد            | بله                | بررسی تغییرات بدون ادغام |
| git pull        | دریافت + ادغام       | دارد             | بله                | بروزرسانی و ادغام فوری   |
| git merge       | ادغام شاخه‌ها        | دارد             | بله (commit merge) | ترکیب تغییرات            |
| git rebase      | بازنویسی commitها    | دارد             | خیر                | ساختار تاریخچه خطی       |
| git cherry-pick | اعمال commit خاص     | دارد             | بله (انتخابی)      | انتقال انتخابی commit    |

---

# ۴. تفاوت دستورات `git reset`، `git revert`، `git restore`، `git switch`، و `git checkout`

در Git برای بازگردانی تغییرات، جابجایی بین شاخه‌ها، و کنترل وضعیت فایل‌ها، دستورات مختلفی ارائه شده است. هر یک از این دستورات کاربرد و اثر خاص خود را دارد.  .

## 1. `git reset`

این دستور برای تغییر مکان HEAD و در صورت نیاز، بازنویسی تاریخچه یا مرحله‌بندی فایل‌ها به‌کار می‌رود. سه حالت اصلی آن عبارت‌اند از:

* `--soft`: فقط HEAD به عقب برمی‌گردد؛ staging و فایل‌ها حفظ می‌شوند.
* `--mixed`: HEAD به عقب برمی‌گردد و staging پاک می‌شود؛ فایل‌ها حفظ می‌شوند.
* `--hard`: HEAD، staging، و فایل‌ها همگی به وضعیت قبلی برمی‌گردند.

مثال:

```bash
git reset --hard HEAD~1
```

نکته: استفاده از `--hard` ممکن است باعث از دست رفتن دائمی داده‌ها شود.

## 2. `git revert`

این دستور برای لغو یک commit خاص استفاده می‌شود، بدون اینکه تاریخچه تغییر کند. Git یک commit جدید ایجاد می‌کند که اثر commit قبلی را خنثی می‌کند. این دستور برای پروژه‌های مشارکتی و ریموت بسیار مناسب و ایمن است.

مثال:

```bash
git revert abc123
```

## 3. `git restore`

این دستور از نسخه ۲.۲۳ به Git اضافه شده و برای بازگردانی فایل‌ها در working directory یا staging area استفاده می‌شود.

مثال‌ها:

```bash
git restore file.txt
git restore --staged file.txt
```

کاربرد اصلی آن لغو تغییرات فایل‌ها یا خارج کردن فایل از حالت staged است.

## 4. `git switch`

این دستور نیز در نسخه ۲.۲۳ معرفی شده و برای جابجایی بین شاخه‌ها استفاده می‌شود. هدف از معرفی آن ساده‌سازی نسبت به `checkout` است.

مثال:

```bash
git switch main
```

این دستور فقط برای تعویض شاخه کاربرد دارد و برای بازیابی فایل‌ها به‌کار نمی‌رود.

## 5. `git checkout`

این دستور قدیمی و چندمنظوره است و هم برای جابجایی بین شاخه‌ها و هم برای بازگردانی فایل‌ها و همچنین ایجاد شاخه جدید استفاده می‌شود.

مثال‌ها:

```bash
git checkout -b new-feature
git checkout main
git checkout file.txt
```

از آنجا که کاربردهای متنوع دارد، ممکن است باعث سردرگمی شود و به همین دلیل دستورات `switch` و `restore` برای وضوح بیشتر معرفی شده‌اند.

## جدول مقایسه

| دستور      | عملکرد اصلی                | تأثیر بر تاریخچه      | ایمنی               | کاربرد رایج                      |
| ---------- | -------------------------- | --------------------- | ------------------- | -------------------------------- |
| `reset`    | بازگرداندن HEAD و staging  | بله (بازنویسی می‌کند) | خطرناک در حالت hard | حذف یا ویرایش commitها           |
| `revert`   | لغو commit با commit معکوس | خیر                   | ایمن                | لغو تغییرات در پروژه‌های اشتراکی |
| `restore`  | بازگردانی فایل‌ها          | خیر                   | ایمن                | لغو تغییرات فایل یا unstaging    |
| `switch`   | جابجایی بین شاخه‌ها        | خیر                   | ایمن                | جابجایی ساده بین شاخه‌ها         |
| `checkout` | جابجایی شاخه یا فایل       | خیر                   | ایمن                | جابجایی قدیمی و چندمنظوره        |


---

# ۵. اstage یا index چیست؟ دستور git stash چه کاری انجام می‌دهد؟

در سیستم Git برای مدیریت تغییرات و کنترل وضعیت فایل‌ها پیش از commit، از مفاهیمی مانند staging area (یا index) و دستور `git stash` استفاده می‌شود. این ابزارها برای مدیریت دقیق‌تر و منعطف‌تر در فرآیند توسعه بسیار حیاتی هستند.

## بخش اول: stage یا index چیست؟

stage که با نام‌های staging area یا index نیز شناخته می‌شود، ناحیه‌ای موقت در Git است که تغییراتی که کاربر قصد commit آن‌ها را دارد، ابتدا در این ناحیه قرار می‌گیرند. این امکان وجود دارد که فقط بخشی از فایل‌های تغییر یافته به staging اضافه شود و نه همه آن‌ها.

### سه ناحیه اصلی در Git:

1. Working Directory: فایل‌هایی که در حال حاضر قابل ویرایش هستند.
2. Staging Area (Index): فایل‌هایی که آماده commit شدن هستند.
3. Commit History: تاریخچه تغییرات ثبت‌شده.

### چرخه معمول کار:

```bash
nano file.txt          # تغییر فایل
git add file.txt       # اضافه به staging
git commit -m "..."    # ثبت تغییر
```

### مزایای staging area:

* قابلیت انتخاب تغییرات برای commit به‌صورت گزینشی
* دسته‌بندی بهتر تغییرات
* استفاده از `git add -p` برای اضافه کردن بخش‌هایی از فایل

## بخش دوم: دستور git stash چیست؟

دستور `git stash` برای ذخیره موقت تغییرات در مخزن محلی استفاده می‌شود. این دستور مخصوص مواقعی است که توسعه‌دهنده نمی‌خواهد تغییرات جاری را commit کند ولی نیاز دارد آن‌ها را کنار بگذارد تا به شاخه دیگری سوئیچ کند یا کار دیگری انجام دهد.

### کاربرد:

* ذخیره‌سازی تغییرات بدون commit
* بازگرداندن تغییرات در آینده

### مثال:

```bash
git stash          # ذخیره تغییرات فعلی
git stash pop      # بازگرداندن آخرین تغییر
```

## عملکرد دقیق git stash

مواردی که stash می‌شود:

* تغییرات فایل‌های موجود
* فایل‌های جدید (در صورت استفاده از `--include-untracked`)
* تغییرات staged و unstaged

### دستورات مرتبط:

| دستور             | توضیح                             |
| ----------------- | --------------------------------- |
| `git stash`       | ذخیره تغییرات فعلی                |
| `git stash list`  | نمایش لیست stashهای ذخیره‌شده     |
| `git stash pop`   | بازگرداندن و حذف stash آخر        |
| `git stash apply` | بازگرداندن بدون حذف از لیست stash |
| `git stash drop`  | حذف یک stash خاص از لیست          |
| `git stash clear` | حذف همه stashهای ذخیره‌شده        |

## تفاوت stage و stash

| ویژگی         | stage (index)               | stash                           |
| ------------- | --------------------------- | ------------------------------- |
| هدف           | آماده‌سازی برای commit      | ذخیره موقت تغییرات              |
| محل ذخیره     | staging area                | در لیست stash داخلی Git         |
| روش مشاهده    | `git status`                | `git stash list`                |
| موارد استفاده | commit کردن بخشی از تغییرات | نگهداری موقت تغییرات برای بعداً |

---

# ۶. مفهوم Snapshot در Git چیست و ارتباط آن با Commit چیست؟

در Git، commitها بر اساس مدل snapshot طراحی شده‌اند، نه مانند سیستم‌هایی که تغییرات را به‌صورت خطی یا تفاوتی (diff-based) ذخیره می‌کنند .

## تعریف snapshot

Snapshot به معنی «عکس فوری از وضعیت کل پروژه در یک لحظه» است. در Git، هر commit در واقع یک snapshot از کل فایل‌های پروژه در زمان خاصی است. این snapshot حاوی محتوای کامل فایل‌ها یا ارجاع به blobهای تغییر‌نیافته است.

### جزئیات عملکرد

* Git هنگام commit کردن، محتوای هر فایل را با الگوریتم SHA-1 هش می‌کند.
* اگر فایل تغییری نکرده باشد، به blob قبلی ارجاع داده می‌شود و نیازی به ذخیره‌سازی دوباره نیست.
* بنابراین فقط فایل‌های تغییر‌یافته snapshot جدیدی تولید می‌کنند و فضای ذخیره بهینه می‌شود.

## تفاوت Git با سیستم‌های diff-based

| ویژگی           | Git (مبتنی بر snapshot)                  | سیستم‌های diff-based (مثل SVN) |
| --------------- | ---------------------------------------- | ------------------------------ |
| نحوه ذخیره‌سازی | ذخیره کل پروژه یا ارجاع به فایل‌های قبلی | فقط ذخیره تفاوت‌ها بین نسخه‌ها |
| امنیت فایل‌ها   | هش‌شده با SHA-1                          | بدون مکانیزم هش داخلی          |
| بازیابی نسخه‌ها | سریع و مستقل از نسخه قبلی                | وابسته به ترتیب نسخه‌های قبلی  |

## تعریف commit در Git

هر commit شامل اطلاعات زیر است:

* یک snapshot از کل فایل‌های پروژه
* پیام commit
* اطلاعات نویسنده و زمان
* ارجاع به commit والد (parent)

در نتیجه، هر commit یک نقطه‌ی مستقل از تاریخچه است که می‌تواند وضعیت دقیق پروژه را بازسازی کند.

## نکته فنی مهم

کاربران Git ممکن است تصور کنند commit فقط شامل تغییرات (diff) است، اما در واقع Git تغییرات را به‌صورت snapshot ذخیره می‌کند و تنها هنگام نمایش diff، تفاوت بین snapshotها را محاسبه می‌کند.

## مثال کاربردی

فرض کنید سه فایل در پروژه وجود دارد:

```
file1.txt
file2.txt
file3.txt
```

در commit اول، snapshot شامل محتوای هر سه فایل است. اگر در commit دوم فقط فایل `file2.txt` تغییر کند:

* Git محتوای جدید `file2.txt` را ذخیره می‌کند.
* برای `file1.txt` و `file3.txt` فقط ارجاع به blobهای قبلی ثبت می‌شود.
* snapshot دوم شامل مجموعه‌ای از ارجاع‌ها و blobهای جدید است.

## مزایای معماری snapshot

| مزیت              | توضیح                                                        |
| ----------------- | ------------------------------------------------------------ |
| امنیت بالا        | هر فایل هش می‌شود و تغییرات غیرمجاز شناسایی‌پذیرند.          |
| بازیابی سریع      | هر commit مستقل است و بازیابی آن نیازی به پردازش diff ندارد. |
| امکان مقایسه دقیق | Git با مقایسه دو snapshot diff ایجاد می‌کند.                 |
| صرفه‌جویی در فضا  | فقط فایل‌های تغییر‌یافته ذخیره می‌شوند.                      |


---

# ۷. تفاوت‌های Local Repository و Remote Repository در Git

Git یک سیستم کنترل نسخه توزیع‌شده (Distributed Version Control System) است. در چنین سیستمی، هر توسعه‌دهنده یک مخزن محلی مستقل دارد که می‌تواند بدون نیاز به اتصال دائم به سرور، تاریخچه پروژه را کامل در اختیار داشته باشد. برای همکاری تیمی و اشتراک‌گذاری تغییرات، از مخازن ریموت استفاده می‌شود.

## Local Repository چیست؟

مخزن محلی همان Git repository است که در سیستم شخصی توسعه‌دهنده وجود دارد. این مخزن با استفاده از دستور `git init` یا `git clone` ایجاد می‌شود.

### اجزای اصلی مخزن محلی:

* `.git/` : شامل داده‌ها، metadata و تنظیمات مربوط به Git
* Working Directory : جایی که توسعه‌دهنده فایل‌ها را ویرایش می‌کند
* Staging Area : بخشی برای آماده‌سازی commit
* Commit History : تاریخچه تغییرات ثبت‌شده

### نمونه ایجاد:

```bash
git init
# یا
git clone https://github.com/user/project.git
```

## Remote Repository چیست؟

مخزن ریموت یک نسخه از مخزن Git است که روی سرور قرار دارد (مثلاً GitHub، GitLab یا Bitbucket). این مخزن معمولاً به‌صورت مشترک بین اعضای یک تیم توسعه استفاده می‌شود.

### ویژگی‌ها:

* روی اینترنت و در دسترس عموم اعضای پروژه قرار دارد.
* از طریق ابزارهایی مانند SSH یا HTTPS قابل اتصال است.
* تغییرات با استفاده از `git push` و `git pull` بین local و remote همگام می‌شود.

### نمونه تنظیم ریموت:

```bash
git remote add origin https://github.com/user/project.git
git push origin main
```

## تفاوت‌های کلیدی بین local و remote

| ویژگی          | Local Repository           | Remote Repository                           |
| -------------- | -------------------------- | ------------------------------------------- |
| محل ذخیره‌سازی | در رایانه شخصی توسعه‌دهنده | روی سرور یا سرویس‌دهنده (GitHub و مشابه آن) |
| دسترسی         | بدون نیاز به اینترنت       | نیازمند اتصال اینترنت                       |
| استقلال        | کاملاً مستقل از سایر مخازن | برای اشتراک‌گذاری و هماهنگی استفاده می‌شود  |
| نوع استفاده    | توسعه فردی یا آزمایشی      | توسعه مشترک و هماهنگ با تیم                 |
| ایجاد با       | `git init` یا `git clone`  | از طریق `git remote` یا پلتفرم‌ها           |
| بروزرسانی      | با commitهای محلی          | با push، pull، fetch                        |

## دستورات رایج برای ارتباط بین local و remote

| دستور            | عملکرد                                    |
| ---------------- | ----------------------------------------- |
| `git remote add` | معرفی مخزن ریموت به پروژه محلی            |
| `git push`       | ارسال commitهای محلی به مخزن ریموت        |
| `git pull`       | دریافت و اعمال تغییرات جدید از مخزن ریموت |
| `git fetch`      | دریافت تغییرات بدون اعمال مستقیم در پروژه |

## مثال کاربردی

```bash
# کلون کردن پروژه از GitHub
git clone https://github.com/user/repo.git

# افزودن تغییرات جدید
git add .
git commit -m "Update documentation"

# ارسال تغییرات به remote
git push origin main

# دریافت آخرین تغییرات از ریموت
git pull origin main
```


---
## تقسیم کار تیمی

برای هماهنگی بین اعضای تیم، از Kanban board استفاده شد. وظایف به صورت کارت‌هایی تعریف شده و بین اعضا تقسیم شد. هر عضو مسئول توسعه یک یا چند بخش از پروژه بود.

- ساختار مخزن و پیاده سازی صفحه پایه: مائده حیدری
- پیاده‌سازی هدر و فوتر: مهدی اکبر
- پیاده‌سازی بخش درباره ما: سپهر واحدی

 Kanban: https://github.com/users/maedehheydari/projects/1/views/1

---

## اعضای تیم

- مائده حیدری – 400104918
- محمدمهدی اکبر – 400104726
- سپهر واحدی – 99170615